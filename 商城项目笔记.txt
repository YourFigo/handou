电商行业的一些常见模式：
    B2C：商家对个人，如：亚马逊、当当等
    C2C平台：个人对个人，如：闲鱼、拍拍网、ebay
    B2B平台：商家对商家，如：阿里巴巴、八方资源网等
    O2O：线上和线下结合，如：饿了么、电影票、团购等
    P2P：在线金融，贷款，如：网贷之家、人人聚财等。
    B2C平台：天猫、京东、一号店等

一些专业术语
SaaS：软件即服务
SOA：面向服务
RPC：远程过程调用
RMI：远程方法调用
PV：(page view)，即页面浏览量；
    用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计
UV：(unique visitor)，独立访客
    指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。
PV与带宽：
    计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。
    计算公式是：网站带宽= ( PV * 平均页面大小（单位MB）* 8 )/统计时间（换算到秒）
    为什么要乘以8？
    网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit
    这个计算的是平均带宽，高峰期还需要扩大一定倍数
PV、QPS、并发
    QPS：每秒处理的请求数量。
    比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。
    由PV和QPS如何需要部署的服务器数量？
    根据二八原则，80%的请求集中在20%的时间来计算峰值压力：
    （每日PV * 80%） / （3600s * 24 * 20%） * 每个页面的请求数  = 每个页面每秒的请求数量
    然后除以服务器的QPS值，即可计算得出需要部署的服务器数量


环境：
jdk 1.8
maven 3.5
springboot 2.0
springcloud Finchley.SR2
mybatis 1.3


模块：
handou：项目整体父工程
handou-registry：服务注册中心（eureka）
handou-gateway：网关和过滤器（zuul）
handou-item：商品聚合模块
    handou-item-interface：负责商品模块对外接口的子模块
    handou-item-service：负责商品模块对内业务的子模块
handou-common：通用工具类模块
handou-manage-web：商城后台管理平台的前端Vue页面

导入 handou-manage-web 项目
package.json中定义了我们所需的一切依赖，安装依赖需要在控制台运行命令：
    npm install
安装好依赖后，可以在package.json中启动项目，运行：
    npm run dev

看一下handou-manage-web的目录结构：
handou-manage-web
├─build
├─config
├─dist
├─node_modules
├─src
│  ├─assets
│  ├─components
│  │  ├─cascader
│  │  ├─form
│  │  ├─messages
│  │  └─tree
│  ├─pages
│  │  ├─item
│  │  │  └─specification
│  │  ├─trade
│  │  └─user
│  ├─router
│  │  └─index.js
│  ├─App.vue
│  ├─config.js
│  ├─http.js
│  ├─main.js
│  └─menu.js
├─static
├─index.html
└─package.json

build：各种编译用的配置文件，package.json中的scripts里面有调用
config：webpack配置文件（webpack：是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。并且提供了前端项目的热部署插件。）
dist：打包输出目录
node_modules：下载的依赖
src/assets：一些图片资源
src/components：一些自定义组件，扩展vuetify中没有的内容
src/pages：具体页面或页面中的组件
src/router/index.js：整个项目的路由跳转配置
src/App.Vue：根vue组件，其他组件在它内部渲染
src/config.js：全局的一些配置信息
src/http.js：ajax请求的相关配置
src/main.js：项目入口文件
src/menu.js：页面菜单中的假数据，后面按需修改
index.html：单页应用唯一的html
package.json：整个vue项目的依赖

理一下清index.html、main.js、App.vue和index.js之间的关系：
    index.html：html模板文件。定义了空的div，其id为app。
    main.js：实例化vue对象，并且通过id选择器绑定到index.html的div中，因此main.js的内容都将在index.html的div中显示。
main.js中使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。index.html引用它之后，就拥有了vue的内容（包括组件、样式等），
所以，main.js也是webpack打包的入口。
    index.js：定义请求路径和组件的映射关系。相当于之前的<vue-router>
    App.vue中也没有内容，而是定义了vue-router的锚点：<router-view>，vue-router路由后的组件将会在锚点展示。
最终结论：一切路由后的内容都将通过App.vue在index.html中显示。
访问流程：用户在浏览器输入路径，例如：http://localhost:9001/#/item/brand --> index.js(/item/brand路径对应pages/item/Brand.vue组件)
--> 该组件显示在App.vue的锚点位置 --> main.js使用了App.vue组件，并把该组件渲染在index.html文件中（id为“app”的div中）

Vuetify框架：
Vuetify基于Material Design（谷歌推出的多平台设计规范），几乎不需要任何CSS代码，拿来就可以用这里的UI组件

SwitchHosts!工具：
修改本地host文件的工具，可以伪造本地的hosts文件，实现对域名的解析。
在webpack.dev.conf.js中取消host验证：disableHostCheck: true，就可以使用域名代替localhost或者127.0.0.1进行访问了。


Nginx：反向代理服务器
域名问题解决了，但是现在要访问后台页面，还得自己加上端口：http://manage.handou.com:9001/，
我们希望的是直接通过域名访问，而不加端口号：http://manage.handou.com。但是不加端口号默认是80端口，如何才能把请求转移到9001端口呢？
可以使用web服务器Nginx。web服务器和web应用服务器的区别：
web应用服务器，如：
    tomcat
    resin
    jetty
web服务器，如：
    Apache 服务器
    Nginx
    IIS
区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。
并发：web服务器的并发能力远高于web应用服务器。

代理和反向代理：正向代理代理的对象时客户端，反向代理代理的对象时服务端。
代理：我们常说的代理就是正向代理，它隐藏了真实请求的客户端，客户端请求的服务都被代理服务器代替来请求，服务器端并不知道真实的客户端。
反向代理：反向代理隐藏了真正的服务端，当我们请求www.baidu.com时，百度可能有成千上万台服务器，具体哪一台正在为我们服务，我们无需知道，我们只需要知道反向代理服务器就可以了。

nginx可以当做反向代理服务器来使用：
    我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理
    当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能

nginx中的目录：
    1. conf：配置目录
    2. contrib：第三方依赖
    3. html：默认的静态资源目录，类似于tomcat的webapps
    4. logs：日志目录
    5. nginx.exe：启动程序。可双击运行，但不建议这么做。

启动nigin：start nginx
重新加载：nginx -s reload
停止：nginx -s stop

修改conf\nginx.conf中的配置：
server_name  改为 ：manage.handou.com
这样就可以在浏览器不输入端口号，直接使用域名就可以访问了，处理流程如下：
    1. 浏览器准备发起请求，访问http://manage.handou.com，但需要进行域名解析
    2. 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1
    3. 请求被发往解析得到的ip，并且默认使用80端口：http://127.0.0.1:80，本机的nginx一直监听80端口，因此捕获这个请求
    4. nginx中配置了反向代理规则，将manage.handou.com代理到127.0.0.1:9001，因此请求被转发（nginx中有配置：proxy_pass http://127.0.0.1:9001;）
    5. 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx
    6. nginx将得到的结果返回到浏览器


编写分类管理相关功能：/item/category
查询分类信息的访问路径：
    http://localhost:8081/category/list?pid=0
    http://api.handou.com/api/item/category/list?pid=0
    api形式的访问路径是在vue的src/config.js中配置的
    浏览器路径是：http://manage.handou.com:9001/#/item/category 但查询时的api路径是：http://api.handou.com/api/item/category/list?pid=0，造成了跨域访问问题。

跨域问题：
Access to XMLHttpRequest at 'http://api.handou.com/api/item/category/list?pid=0' from origin 'http://manage.handou.com:9001'
has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
跨域：浏览器对于javascript的同源策略的限制。下面几种情况都属于跨域：
    1、域名不同  www.jd.com 与 www.taobao.com
    2、端口不同  www.jd.com:8080 与 www.jd.com:8081
    3、二级域名不同 item.jd.com 与 miaosha.jd.com
    4、http和https也属于跨域
如果域名和端口都相同，但是请求路径不同，不属于跨域，如：
    www.jd.com/item
    www.jd.com/goods
跨域不一定都会有跨域问题：
因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是与当前页域名相同的路径，这能有效的阻止跨站攻击。因此，跨域问题 是针对ajax的一种限制。
但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，这需要我们解决跨域问题。
解决跨域问题的方案：
Jsonp
  最早的解决方案，利用script标签可以跨域的原理实现。
  限制：
    需要服务的支持
    只能发起GET请求
nginx反向代理
  思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式
  缺点：需要在nginx进行额外配置，语义不清晰
CORS
  规范化的跨域请求解决方案，安全可靠。
  优势：
    在服务端进行控制是否允许跨域，可自定义规则
    支持各种请求方式
  缺点：
    会产生额外的请求

cors解决跨域：
CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，
发出XMLHttpRequest(http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，
从而克服了AJAX只能同源(http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。
CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。
浏览器端：
    目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。
服务端：
    CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，
    我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。
浏览器会将ajax请求分为两类简单请求、特殊请求：
简单请求：
只要同时满足以下两大条件，就属于简单请求：
    (1)请求方法是以下三种方法之一：
        HEAD
        GET
        POST
    (2)HTTP的头信息不超出以下几种字段：
        Accept
        Accept-Language
        Content-Language
        Last-Event-ID
        Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：Origin: http://manage.handou.com:9001
Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。
如果服务器允许跨域，需要在返回的响应头中携带下面信息：
    Access-Control-Allow-Origin: http://manage.handou.com
    Access-Control-Allow-Credentials: true
    Content-Type: text/html; charset=utf-8
Access-Control-Allow-Origin：允许哪个域名进行跨域，是一个具体域名或者*（代表任意域名）
Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true
要想操作cookie，需要满足3个条件：
    服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。
    浏览器发起ajax需要指定withCredentials 为true
    响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名
特殊请求：
不符合简单请求的条件，会被浏览器判定为特殊请求,例如请求方式为PUT。
预检请求：
特殊请求会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求(preflight)。
浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。
只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
一个“预检”请求的样板：
    OPTIONS /cors HTTP/1.1
    Origin: http://manage.handou.com
    Access-Control-Request-Method: PUT
    Access-Control-Request-Headers: X-Custom-Header
    Host: api.handou.com
    Accept-Language: en-US
    Connection: keep-alive
    User-Agent: Mozilla/5.0...
与简单请求相比，除了Origin以外，多了两个头：
    Access-Control-Request-Method：接下来会用到的请求方式，比如PUT
    Access-Control-Request-Headers：会额外用到的头信息
预检请求的响应：
服务的收到预检请求，如果许可跨域，会发出响应：
    HTTP/1.1 200 OK
    Date: Mon, 01 Dec 2008 01:15:39 GMT
    Server: Apache/2.0.61 (Unix)
    Access-Control-Allow-Origin: http://manage.handou.com
    Access-Control-Allow-Credentials: true
    Access-Control-Allow-Methods: GET, POST, PUT
    Access-Control-Allow-Headers: X-Custom-Header
    Access-Control-Max-Age: 1728000
    Content-Type: text/html; charset=utf-8
    Content-Encoding: gzip
    Content-Length: 0
    Keep-Alive: timeout=2, max=100
    Connection: Keep-Alive
    Content-Type: text/plain
除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头：
    Access-Control-Allow-Methods：允许访问的方式
    Access-Control-Allow-Headers：允许携带的头
    Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了
如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。

实现跨域访问：在网关（zuul）中编写一个配置类，并且注册CorsFilter：
SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。
服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。
在网关中创建一个CorsFilter的跨域访问过滤器类：HandouCorsConfiguration

前端异步查询工具axios
异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。
因此不可能为了发起ajax请求而去引用这么大的一个库。Vue官方推荐的ajax请求框架叫做：axios
axios的Get请求语法：
    axios.get("/item/category/list?pid=0") // 请求路径和请求参数拼接
        .then(function(resp){
            // 成功回调函数
        })
        .catch(function(){
            // 失败回调函数
        })
    // 参数较多时，可以通过params来传递参数
    axios.get("/item/category/list", {
            params:{
                pid:0
            }
        })
        .then(function(resp){})// 成功时的回调
        .catch(function(error){})// 失败时的回调

axios的POST请求语法：
比如新增一个用户
    axios.post("/user",{
            name:"Jack",
            age:21
        })
        .then(function(resp){})
        .catch(function(error){})
注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数
PUT和DELETE请求与POST请求类似
我们这里的使用是在：
    getDataFromServer() { // 从服务的加载数的方法。
        // 发起请求
        this.$http.get("/item/brand/page", {
          params: {
            key: this.search, // 搜索条件
            page: this.pagination.page,// 当前页
            rows: this.pagination.rowsPerPage,// 每页大小
            sortBy: this.pagination.sortBy,// 排序字段
            desc: this.pagination.descending// 是否降序
          }
        }).then(resp => { // 这里使用箭头函数
          this.brands = resp.data.items;
          this.totalBrands = resp.data.total;
          // 完成赋值后，把加载状态赋值为false
          this.loading = false;
        })
      }
我们这里没有使用axios而是使用了this.$http，因为我们在src/http.js中做了封装：
    // 将axios添加到 Vue的原型，这样一切vue实例都可以使用该对象
    Vue.prototype.$http = axios;


json对象转换为查询字符串
请求的数据格式是一个JSON对象，在controller中只能使用一个对象接收，不能使用两个参数接收，否则报400错误。
axios处理请求体的原则会根据请求数据的格式来定：
    如果请求体是对象：会转为json发送
    如果请求体是String：会作为普通表单请求发送，但需要我们自己保证String的格式是键值对。如：name=jack&age=12
可以使用QS工具，在前端将json数据转换为请求参数字符串
    QS是一个第三方库，我们可以用 npm install qs --save 来安装。
    QS，即Query String，请求参数字符串。例如： name=jack&age=21
    QS工具可以便捷的实现 JS的Object与QueryString的转换。